# -*- coding: utf-8 -*-
"""MLIindex.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cll4ibioRUgQMNb53hd5NDis88a8C0oi

Authors: Maximilian Van Zandt, Clayton Walther, Mehul Pol, Andrew Hunter
"""

import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.offline import plot
import plotly.express as px
import matplotlib.pyplot as plt
import seaborn as sns
import os

# Set root directory and reproducibility
root_dir = os.getcwd()
np.random.seed(42)

def load_static_data():
    """Load non-tracking data files"""
    try:
        games = pd.read_csv(os.path.join(root_dir, "data/games.csv"))
        players = pd.read_csv(os.path.join(root_dir, "data/players.csv"))
        plays = pd.read_csv(os.path.join(root_dir, "data/plays.csv"))
        player_play = pd.read_csv(os.path.join(root_dir, "data/player_play.csv"))
        return games, players, plays, player_play
    except FileNotFoundError as e:
        print(f"Error loading static data: {e}")
        return None, None, None, None

def load_tracking_data(weeks=range(1, 10)):
    """Load and combine tracking data from multiple weeks"""
    try:
        all_weeks = []
        for week in weeks:
            week_data = pd.read_csv(os.path.join(root_dir, f"data/tracking_week_{week}.csv"))
            all_weeks.append(week_data)

        tracking_data = pd.concat(all_weeks, ignore_index=True)
        tracking_data['time'] = pd.to_datetime(tracking_data['time'], errors='coerce')
        return tracking_data
    except FileNotFoundError as e:
        print(f"Error loading tracking data: {e}")
        return None

# Load all data
print("Loading static data...")
games, players, plays, player_play = load_static_data()

print("Loading tracking data...")
week1 = load_tracking_data()
week1['time'] = pd.to_datetime(week1['time'], errors='coerce')


# Verify data loading
if all(v is not None for v in [games, players, plays, player_play, week1]):
    print("All data loaded successfully")
else:
    print("Error loading some data files")

"""# Importance of motion play
Show how often motions are used by team/game? (EDA)

Data Visualization
"""

#Clean Data
filtered_plays = plays[(plays["qbKneel"] == 0) & (plays['qbSpike'] == 0) | (plays['qbSpike'].isna())]

rush = player_play.groupby(['gameId', 'playId'])['hadRushAttempt'].sum().reset_index(name='rush')
filtered_rush = filtered_plays.merge(rush, on=['gameId', 'playId'], how='inner')
filtered_rush = filtered_rush[filtered_rush['rush'] == 1]

motion = player_play.groupby(['gameId', 'playId'])['motionSinceLineset'].any().reset_index(name='hasMotion')
final_data = filtered_rush.merge(motion, on=['gameId', 'playId'], how='left')

### OR FOR ALL PLAYS
#final_data = filtered_plays.merge(motion, on=['gameId', 'playId'], how='left')
###

### OR FOR PLAY ACTION
#filtered_pa = filtered_plays[filtered_plays['playAction'] == True]
#final_data = filtered_pa.merge(motion, on=['gameId', 'playId'], how='left')
###

final_data['hasMotion'] = final_data['hasMotion'].fillna(False)

# Group by possessionTeam and calculate percentage of plays with motion
team_motion_summary = final_data.groupby('possessionTeam')['hasMotion'].mean() * 100
team_motion_summary = team_motion_summary.reset_index()
team_motion_summary.rename(columns={'hasMotion': 'Percentage'}, inplace=True)

# Sort teams by percentage for better visualization
team_motion_summary = team_motion_summary.sort_values(by='Percentage', ascending=False)

# Assign Teams to colors
team_colors = {
        'ARI': '#97233F', 'ATL': '#A71930', 'BAL': '#241773', 'BUF': '#00338D',
        'CAR': '#0085CA', 'CHI': '#0B162A', 'CIN': '#FB4F14', 'CLE': '#311D00',
        'DAL': '#003594', 'DEN': '#FB4F14', 'DET': '#0076B6', 'GB': '#203731',
        'HOU': '#03202F', 'IND': '#002C5F', 'JAX': '#101820', 'KC': '#E31837',
        'LA': '#003594', 'LAC': '#0080C6', 'LV': '#000000', 'MIA': '#008E97',
        'MIN': '#4F2683', 'NE': '#002244', 'NO': '#101820', 'NYG': '#0B2265',
        'NYJ': '#125740', 'PHI': '#004C54', 'PIT': '#FFB612', 'SEA': '#002244',
        'SF': '#AA0000', 'TB': '#D50A0A', 'TEN': '#0C2340', 'WAS': '#5A1414'
    }

# Plotting with Seaborn
sns.set_theme(style="whitegrid")
plt.figure(figsize=(12, 8))
ax = sns.barplot(x='Percentage', y='possessionTeam', data=team_motion_summary,
                 palette=[team_colors[team] for team in team_motion_summary['possessionTeam']])

# Customize plot
ax.set_title("Percentage of Run Plays with Motion by Team", fontsize=16)
ax.set_xlabel("Percentage (%)", fontsize=14)
ax.set_ylabel("Team", fontsize=14)
ax.set_xlim(0, 100)

# Annotate bars with values
for p in ax.patches:
    ax.annotate(f"{p.get_width():.2f}%",
                (p.get_width(), p.get_y() + p.get_height() / 2),
                ha='left', va='center', fontsize=10, color='black', xytext=(5, 0),
                textcoords='offset points')

plt.tight_layout()
plt.show()

"""## Example Motion Play

Code used from:

HuntingData11. (2020). Animated and Interactive NFL Plays in Plotly. Kaggle. Retrieved from https://www.kaggle.com/code/huntingdata11/animated-and-interactive-nfl-plays-in-plotly/notebook
"""

# You can inherit these colors from nflverse, this is for completeness/convenience
colors = {
    'ARI':["#97233F","#000000","#FFB612"],
    'ATL':["#A71930","#000000","#A5ACAF"],
    'BAL':["#241773","#000000"],
    'BUF':["#00338D","#C60C30"],
    'CAR':["#0085CA","#101820","#BFC0BF"],
    'CHI':["#0B162A","#C83803"],
    'CIN':["#FB4F14","#000000"],
    'CLE':["#311D00","#FF3C00"],
    'DAL':["#003594","#041E42","#869397"],
    'DEN':["#FB4F14","#002244"],
    'DET':["#0076B6","#B0B7BC","#000000"],
    'GB' :["#203731","#FFB612"],
    'HOU':["#03202F","#A71930"],
    'IND':["#002C5F","#A2AAAD"],
    'JAX':["#101820","#D7A22A","#9F792C"],
    'KC' :["#E31837","#FFB81C"],
    'LA' :["#003594","#FFA300","#FF8200"],
    'LAC':["#0080C6","#FFC20E","#FFFFFF"],
    'LV' :["#000000","#A5ACAF"],
    'MIA':["#008E97","#FC4C02","#005778"],
    'MIN':["#4F2683","#FFC62F"],
    'NE' :["#002244","#C60C30","#B0B7BC"],
    'NO' :["#101820","#D3BC8D"],
    'NYG':["#0B2265","#A71930","#A5ACAF"],
    'NYJ':["#125740","#000000","#FFFFFF"],
    'PHI':["#004C54","#A5ACAF","#ACC0C6"],
    'PIT':["#FFB612","#101820"],
    'SEA':["#002244","#69BE28","#A5ACAF"],
    'SF' :["#AA0000","#B3995D"],
    'TB' :["#D50A0A","#FF7900","#0A0A08"],
    'TEN':["#0C2340","#4B92DB","#C8102E"],
    'WAS':["#5A1414","#FFB612"],
    'football':["#CBB67C","#663831"]
}

def preprocess_data(tracking_data, players_data):
    """
    merges data for the `animate_play()` function
    """
    tracking_df = pd.merge(tracking_data,players_data,how="left",on = ["nflId",'displayName'])
    return tracking_df

def hex_to_rgb_array(hex_color):
    """
    take in hex val and return rgb np array
    helper for 'color distance' issues
    """
    return np.array(tuple(int(hex_color.lstrip('#')[i:i+2], 16) for i in (0, 2, 4)))

def ColorDistance(hex1,hex2):
    """
    d = {} distance between two colors(3)
    helper for 'color distance' issues
    """
    if hex1 == hex2:
        return 0
    rgb1 = hex_to_rgb_array(hex1)
    rgb2 = hex_to_rgb_array(hex2)
    rm = 0.5*(rgb1[0]+rgb2[0])
    d = abs(sum((2+rm,4,3-rm)*(rgb1-rgb2)**2))**0.5
    return d

def ColorPairs(team1,team2):
    """
    Pairs colors given two teams
    If colors are 'too close' in hue, switch to alt color
    """
    color_array_1 = colors[team1]
    color_array_2 = colors[team2]
    # If color distance is small enough then flip color order
    if ColorDistance(color_array_1[0],color_array_2[0])<500:
        return {
          team1:[color_array_1[0],color_array_1[1]],
          team2:[color_array_2[1],color_array_2[0]],
          'football':colors['football']
        }
    else:
        return {
          team1:[color_array_1[0],color_array_1[1]],
          team2:[color_array_2[0],color_array_2[1]],
          'football':colors['football']
        }

def animate_play(games,tracking_df,play_df,players,gameId,playId):
    """
    Generates an animated play using the tracking data.
    """
    selected_game_df = games.loc[games['gameId']==gameId].copy()
    selected_play_df = play_df.loc[(play_df['playId']==playId) & (play_df['gameId']==gameId)].copy()

    tracking_players_df = tracking_df.copy()
    selected_tracking_df = tracking_players_df.loc[(tracking_players_df['playId']==playId)&(tracking_players_df['gameId']==gameId)].copy()

    sorted_frame_list = selected_tracking_df.frameId.unique()
    sorted_frame_list.sort()

    # get good color combos
    team_combos = list(set(selected_tracking_df['club'].unique())-set(['football']))
    color_orders = ColorPairs(team_combos[0],team_combos[1])

    # get play General information
    line_of_scrimmage = selected_play_df['absoluteYardlineNumber'].values[0]

    # Fixing first down marker issue from last year
    if selected_tracking_df['playDirection'].values[0] == 'right':
        first_down_marker = line_of_scrimmage + selected_play_df['yardsToGo'].values[0]
    else:
        first_down_marker = line_of_scrimmage - selected_play_df['yardsToGo'].values[0]
    down = selected_play_df['down'].values[0]
    quarter = selected_play_df['quarter'].values[0]
    gameClock = selected_play_df['gameClock'].values[0]
    playDescription = selected_play_df['playDescription'].values[0]

    # Handle case where we have a really long Play Description and want to split it into two lines
    if len(playDescription.split(" "))>15 and len(playDescription)>115:
        playDescription = " ".join(playDescription.split(" ")[0:16]) + "<br>" + " ".join(playDescription.split(" ")[16:])

    # initialize plotly start and stop buttons for animation
    updatemenus_dict = [
      {
          "buttons": [
              {
                  "args": [None, {"frame": {"duration": 100, "redraw": False},
                              "fromcurrent": True, "transition": {"duration": 0}}],
                  "label": "Play",
                  "method": "animate"
              },
              {
                  "args": [[None], {"frame": {"duration": 0, "redraw": False},
                                    "mode": "immediate",
                                    "transition": {"duration": 0}}],
                  "label": "Pause",
                  "method": "animate"
              }
          ],
          "direction": "left",
          "pad": {"r": 10, "t": 87},
          "showactive": False,
          "type": "buttons",
          "x": 0.1,
          "xanchor": "right",
          "y": 0,
          "yanchor": "top"
      }
    ]
    # initialize plotly slider to show frame position in animation
    sliders_dict = {
      "active": 0,
      "yanchor": "top",
      "xanchor": "left",
      "currentvalue": {
          "font": {"size": 20},
          "prefix": "Frame:",
          "visible": True,
          "xanchor": "right"
      },
      "transition": {"duration": 300, "easing": "cubic-in-out"},
      "pad": {"b": 10, "t": 50},
      "len": 0.9,
      "x": 0.1,
      "y": 0,
      "steps": []
    }


    frames = []
    for frameId in sorted_frame_list:
        data = []
        # Add Numbers to Field
        data.append(
          go.Scatter(
              x=np.arange(20,110,10),
              y=[5]*len(np.arange(20,110,10)),
              mode='text',
              text=list(map(str,list(np.arange(20, 61, 10)-10)+list(np.arange(40, 9, -10)))),
              textfont_size = 30,
              textfont_family = "Courier New, monospace",
              textfont_color = "#ffffff",
              showlegend=False,
              hoverinfo='none'
          )
        )
        data.append(
          go.Scatter(
              x=np.arange(20,110,10),
              y=[53.5-5]*len(np.arange(20,110,10)),
              mode='text',
              text=list(map(str,list(np.arange(20, 61, 10)-10)+list(np.arange(40, 9, -10)))),
              textfont_size = 30,
              textfont_family = "Courier New, monospace",
              textfont_color = "#ffffff",
              showlegend=False,
              hoverinfo='none'
          )
        )
        # Add line of scrimage
        data.append(
          go.Scatter(
              x=[line_of_scrimmage,line_of_scrimmage],
              y=[0,53.5],
              line_dash='dash',
              line_color='blue',
              showlegend=False,
              hoverinfo='none'
          )
        )
        # Add First down line
        data.append(
          go.Scatter(
              x=[first_down_marker,first_down_marker],
              y=[0,53.5],
              line_dash='dash',
              line_color='yellow',
              showlegend=False,
              hoverinfo='none'
          )
        )
        # Add Endzone Colors
        endzoneColors = {0:color_orders[selected_game_df['homeTeamAbbr'].values[0]][0],
                        110:color_orders[selected_game_df['visitorTeamAbbr'].values[0]][0]}
        for x_min in [0,110]:
            data.append(
              go.Scatter(
                  x=[x_min,x_min,x_min+10,x_min+10,x_min],
                  y=[0,53.5,53.5,0,0],
                  fill="toself",
                  fillcolor=endzoneColors[x_min],
                  mode="lines",
                  line=dict(
                      color="white",
                      width=3
                      ),
                  opacity=1,
                  showlegend= False,
                  hoverinfo ="skip"
              )
            )
        # Plot Players
        for team in selected_tracking_df['club'].unique():
            plot_df = selected_tracking_df.loc[(selected_tracking_df['club']==team) & (selected_tracking_df['frameId']==frameId)].copy()

            if team != 'football':
                hover_text_array=[]

                for nflId in plot_df['nflId'].unique():
                    selected_player_df = plot_df.loc[plot_df['nflId']==nflId]
                    nflId = int(selected_player_df['nflId'].values[0])
                    displayName = selected_player_df['displayName'].values[0]
                    s = round(selected_player_df['s'].values[0] * 2.23693629205, 3)
                    text_to_append = f"nflId:{nflId}<br>displayName:{displayName}<br>Player Speed:{s} MPH"
                    hover_text_array.append(text_to_append)

                data.append(go.Scatter(x=plot_df['x'], y=plot_df['y'],
                                      mode = 'markers',
                                      marker=go.scatter.Marker(color=color_orders[team][0],
                                                              line=go.scatter.marker.Line(width=2,
                                                                                          color=color_orders[team][1]),
                                                              size=10),
                                      name=team,hovertext=hover_text_array,hoverinfo='text'))
            else:
                data.append(go.Scatter(x=plot_df['x'], y=plot_df['y'],
                                      mode = 'markers',
                                      marker=go.scatter.Marker(
                                        color=color_orders[team][0],
                                        line=go.scatter.marker.Line(width=2,
                                                                    color=color_orders[team][1]),
                                        size=10),
                                      name=team,hoverinfo='none'))
        # add frame to slider
        slider_step = {'args': [
          [frameId],
          {'frame': {'duration': 100, 'redraw': False},
            'mode': 'immediate',
            'transition': {'duration': 0}}
        ],
          'label': str(frameId),
          'method': 'animate'}
        sliders_dict['steps'].append(slider_step)
        frames.append(go.Frame(data=data, name=str(frameId)))

    scale=10
    layout = go.Layout(
        autosize=False,
        width=120*scale,
        height=60*scale,
        xaxis=dict(range=[0, 120], autorange=False, tickmode='array',tickvals=np.arange(10, 111, 5).tolist(),showticklabels=False),
        yaxis=dict(range=[0, 53.3], autorange=False,showgrid=False,showticklabels=False),

        plot_bgcolor='#00B140',
        # Create title and add play description at the bottom of the chart for better visual appeal
        title=f"GameId: {gameId}, PlayId: {playId}<br>{gameClock} {quarter}Q"+"<br>"*19+f"{playDescription}",
        updatemenus=updatemenus_dict,
        sliders = [sliders_dict]
    )

    fig = go.Figure(
        data=frames[0]['data'],
        layout= layout,
        frames=frames[1:]
    )
    # Create First Down Markers
    for y_val in [0,53]:
        fig.add_annotation(
              x=first_down_marker,
              y=y_val,
              text=str(down),
              showarrow=False,
              font=dict(
                  family="Courier New, monospace",
                  size=16,
                  color="black"
                  ),
              align="center",
              bordercolor="black",
              borderwidth=2,
              borderpad=4,
              bgcolor="#ff7f0e",
              opacity=1
              )
    # Add Team Abbreviations in EndZone's
    for x_min in [0,110]:
        if x_min == 0:
            angle = 270
            teamName=selected_game_df['homeTeamAbbr'].values[0]
        else:
            angle = 90
            teamName=selected_game_df['visitorTeamAbbr'].values[0]
        fig.add_annotation(
          x=x_min+5,
          y=53.5/2,
          text=teamName,
          showarrow=False,
          font=dict(
              family="Courier New, monospace",
              size=32,
              color="White"
              ),
          textangle = angle
        )
    return fig

def find_successful_motion_plays(plays, player_play, team):
    # Find plays where KC used motion effectively
    team_plays = plays[plays['possessionTeam'] == team]

    # Merge with player_play to get motion information
    motion_plays = team_plays.merge(
        player_play.groupby(['gameId', 'playId'])['motionSinceLineset'].sum().reset_index(),
        on=['gameId', 'playId']
    )

    # Filter for plays with motion
    motion_plays = motion_plays[
        (motion_plays['motionSinceLineset'] > 0) &
        (motion_plays['expectedPointsAdded'] > 0)
    ]

    return motion_plays.sort_values('expectedPointsAdded', ascending=False)

def visualize_motion_success(games, plays, player_play, tracking_data, team):
    # Find top motion plays
    successful_plays = find_successful_motion_plays(plays, player_play, team)

    # Get the top play
    example_play = successful_plays.iloc[0]

    # Create animation
    fig = animate_play(
        games=games,
        tracking_df=tracking_data,
        play_df=plays,
        players=players,
        gameId=example_play['gameId'],
        playId=example_play['playId']
    )

    return fig

fig = visualize_motion_success(games, plays, player_play, week1, 'MIN')
fig.show()

"""# Motion Leverage Index (MLI)

Building upon the motion success rate, it's

Formula:
$$ MLI = (MS * DD * TE) * (FPM * DLM) * (1 - PR) $$
Where:
- MS = Motion Success Rate
- DD = Defensive Displacement
- TE = Timing Efficiency
- FPM = Field Position Multiplier
- DLM = Down-Distance Leverage Multiplier
- PR = Penalty Risk

Expanded Formula:
$$ MLI = \left(\frac{\sum_{i=1}^{n} (Success_i * (1 + EPA_i))}{n} * \sqrt{(\bar{x}_{snap} - \bar{x}_{pre})^2 + (\bar{y}_{snap} - \bar{y}_{pre})^2} * (1-\frac{t_{motion}}{t_{max}})\right) * \left((1 + \frac{100-y_f}{100}) * (w_d + \frac{10-y_g}{10})\right) * (1-penalty\_freq * \overline{|EPA_{penalties}|}) $$

Where:
- $Success_i$ is 1 if play i gains required yards based on down (40%/50%/70%/70%)
- $EPA_i$ is expected points added, clipped to [-1,1]
- $\bar{x}, \bar{y}$ are defensive formation centroids pre-motion and at snap
- $t_{motion}$ is time between motion and snap
- $t_{max}$ is maximum pre-snap time
- $y_f$ is field position (yards from goal)
- $w_d$ is down weight {1:1.0, 2:0.7, 3:0.5, 4:0.3}
- $y_g$ is yards to go
- $penalty\_freq$ is motion penalties per total plays
- $\overline{|EPA_{penalties}|}$ is mean absolute EPA of penalties

MLI Code
"""

# Define the modified calculate_modified_ms function
def calculate_modified_ms(plays, player_play):
    def get_play_success(play):
        # Base success criteria by down
        success_thresholds = {
            1: 0.4,  # 40% of yards needed on 1st down
            2: 0.5,  # 50% of yards needed on 2nd down
            3: 0.7,  # 70% of yards needed on 3rd/4th down
            4: 1.0
        }

        yards_needed = success_thresholds[play['down']] * play['yardsToGo']
        return play['yardsGained'] >= yards_needed

    # Get motion plays
    motion_plays = plays.merge(
        player_play.groupby(['gameId', 'playId'])['motionSinceLineset'].sum().reset_index(),
        on=['gameId', 'playId']
    )
    motion_plays = motion_plays[motion_plays['motionSinceLineset'] > 0]

    # Calculate success rate with defensive adjustment
    motion_plays['play_success'] = motion_plays.apply(get_play_success, axis=1)

    # Add EPA weight
    motion_plays['success_value'] = motion_plays['play_success'] * \
                                  (1 + motion_plays['expectedPointsAdded'].clip(-1, 1))

    return motion_plays['success_value'].mean()

# Analyze pre-snap penalties
def analyze_presnap_penalties(plays, player_play):
    presnap_penalties = plays[
        (abs(plays['penaltyYards']) == 5)
    ]

    motion_penalty_data = presnap_penalties.merge(
        player_play[['gameId', 'playId', 'motionSinceLineset',
                       'inMotionAtBallSnap']],
        on=['gameId', 'playId']
    )

    return motion_penalty_data

# Create motion_penalty_data
motion_penalty_data = analyze_presnap_penalties(plays, player_play)

# Create penalty data
def create_penalty_data(motion_penalty_data, plays):
    penalty_data = motion_penalty_data.merge(
        plays[['gameId', 'playId', 'possessionTeam']],
        on=['gameId', 'playId'],
        how='left',
        suffixes=('', '_drop')
    )

    penalty_data = penalty_data[['gameId', 'playId', 'possessionTeam']]
    return penalty_data

# Create penalty_data
penalty_data = create_penalty_data(motion_penalty_data, plays)

# Fix for calculate_mli with Option 2
def calculate_mli(week1, plays, penalty_data, player_play):
    def safe_mean(series):
            return series.mean() if len(series) > 0 else 0

        # Replace the old calculate_ms with the new one
    def calculate_ms(team_plays, team_player_play):
            if team_plays.empty or team_player_play.empty:
                return 0.0
            # Filter for team-specific plays
            team_motion_success = calculate_modified_ms(team_plays, team_player_play)
            return float(team_motion_success) if not pd.isna(team_motion_success) else 0.0

    def calculate_dd(week1, plays, player_play):
        # First, merge player_play data to get motion information
        motion_plays = plays.merge(
            player_play.groupby(['gameId', 'playId'])['motionSinceLineset'].sum().reset_index(),
            on=['gameId', 'playId']
        )
        motion_plays = motion_plays[motion_plays['motionSinceLineset'] > 0]

        if motion_plays.empty:
            return 0

        # Define get_defensive_movement to accept a single row
        def get_defensive_movement(row):
            # Filter tracking data for specific game and play
            play_tracking = week1[
                (week1['gameId'] == row['gameId']) &
                (week1['playId'] == row['playId'])
            ]

            # Get the defensive team (this should always be the opposing team's defense)
            defensive_team = row['defensiveTeam']

            # Get pre-snap and snap frames
            pre_snap = play_tracking[play_tracking['event'] == 'man_in_motion']
            snap = play_tracking[play_tracking['event'] == 'ball_snap']

            if len(pre_snap) == 0 or len(snap) == 0:
                return 0

            # Get positions of the defensive players
            def_pre = pre_snap[pre_snap['club'] == defensive_team][['x', 'y']]
            def_snap = snap[snap['club'] == defensive_team][['x', 'y']]

            if len(def_pre) == 0 or len(def_snap) == 0:
                return 0

            # Calculate displacement between pre-snap and snap
            displacement = np.sqrt(
                ((def_snap.mean() - def_pre.mean()) ** 2).sum()
            )

            return displacement

        # Apply the function to each row and return the average displacement
        return safe_mean(motion_plays.apply(get_defensive_movement, axis=1))

    ################################

    def calculate_te(week1):
        try:
            # Find gameId and playId combinations that have both 'ball_snap' and 'man_in_motion'
            valid_play_ids = week1.groupby(['gameId', 'playId'])['event'].apply(
                lambda x: {'ball_snap', 'man_in_motion'}.issubset(x.unique())
            )
            valid_play_ids = valid_play_ids[valid_play_ids].index

            # Filter tracking_data to only include valid playId combinations
            valid_tracking_data = week1[week1.set_index(['gameId', 'playId']).index.isin(valid_play_ids)]

            # Now, calculate motion to snap
            motion_to_snap = valid_tracking_data.groupby('playId').apply(
                lambda x: x[x['event'] == 'ball_snap']['time'].iloc[0] -
                          x[x['event'] == 'man_in_motion']['time'].iloc[0]
            )

            # Return the result
            return (1 - (motion_to_snap / motion_to_snap.max())).mean()

        except (IndexError, KeyError) as e:
            print(f"Error: {e}")  # Debugging line
            return 0

    def calculate_fpm(plays):
            if 'absoluteYardlineNumber' in plays.columns:
                field_position = plays['absoluteYardlineNumber']
            else:
                field_position = plays['yardlineNumber']
            return 1 + safe_mean((100 - field_position.fillna(0)) / 100)

    def calculate_dlm(plays):
        # Create down weights
            down_weights = {1: 1.0, 2: 0.7, 3: 0.5, 4: 0.3}
            plays = plays.copy()  # Avoid modifying the original DataFrame
            plays.loc[:, 'downWeight'] = plays['down'].map(down_weights).fillna(0)
            return safe_mean(plays['downWeight'] + ((10 - plays['yardsToGo'].fillna(0)) / 10))

    def calculate_pr(penalty_data, team):
            team_penalties = penalty_data[penalty_data['possessionTeam'] == team]
            return len(team_penalties) / max(len(penalty_data), 1)

        # Vectorized MLI Calculation
    team_metrics = {}
    team_components = {}

    for team in plays['possessionTeam'].unique():
        team_plays = plays[(plays['possessionTeam'] == team)]
        team_tracking = week1[week1['club'] == team]
        opp_tracking = week1[week1['club'] != team]
        team_player_play = player_play[player_play['teamAbbr'] == team]

        # Calculate components
        ms = max(0.001, calculate_ms(team_plays, team_player_play))  # Motion Success
        dd = max(0.001, calculate_dd(opp_tracking, team_plays, team_player_play))  # Defensive Displacement
        te = max(0.001, calculate_te(team_tracking))  # Timing Efficiency
        pr = min(0.999, calculate_pr(penalty_data, team))  # Penalty Risk
        fpm = max(0.001, calculate_fpm(team_plays))  # Field Position Modifier
        dlm = max(0.001, calculate_dlm(team_plays))  # Down & Distance Modifier

        # Calculate MLI
        mli = (ms * dd * te) * (fpm * dlm) * (1 - pr)
        team_metrics[team] = mli if not pd.isna(mli) else 0.0

        # Store components
        team_components[team] = {
            'Motion Success': ms,
            'Defensive Displacement': dd,
            'Timing Efficiency': te,
            'Penalty Risk': pr,
            'Field Position Modifier': fpm,
            'Down & Distance Modifier': dlm
        }

    # Create MLI DataFrame with Normalization
    mli_df = pd.DataFrame.from_dict(team_metrics, orient='index', columns=['MLI'])

    # Handle edge cases in normalization
    if len(mli_df) > 1:
        mli_df['MLI'] = ((mli_df['MLI'] - mli_df['MLI'].min()) /
                         (mli_df['MLI'].max() - mli_df['MLI'].min())) * 100
    else:
        mli_df['MLI'] = 100  # Default if only one team

    return mli_df, team_components

# Calculate MLI
mli_df, components = calculate_mli(week1, plays, penalty_data, player_play)

def analyze_mli_rankings(mli_df, plays, player_play):
    # 1. Overall Rankings with Tiers
    mli_df['Tier'] = pd.qcut(mli_df['MLI'], q=4, labels=['Low', 'Medium', 'High', 'Elite'])

    print("MLI Rankings by Tier:")
    for tier in ['Elite', 'High', 'Medium', 'Low']:
        tier_teams = mli_df[mli_df['Tier'] == tier]
        print(f"\n{tier} Tier Teams:")
        print(tier_teams.sort_values('MLI', ascending=False))

def generate_team_report(team, mli_df, components):
    """Generate comprehensive team report"""
    print(f"\nTeam Report: {team}")

    # Overall MLI Ranking
    team_mli = mli_df.loc[team, 'MLI']
    print(f"Overall MLI: {team_mli:.2f}")
    print(f"League Rank: {mli_df['MLI'].rank(ascending=False)[team]}/32")

    # Component Breakdown
    print("\nComponent Breakdown:")
    team_components = components[team]
    for component, value in team_components.items():
        print(f"{component}: {value:.3f}")


# Example Usage:
# Overall League Analysis
mli_rank = analyze_mli_rankings(mli_df, plays, player_play)

# Detailed Analysis for Elite Team (MIN), High Team (CHI), Medium Team (WAS), and Low Team (NYG)
generate_team_report('MIN', mli_df, components)
generate_team_report('CHI', mli_df, components)
generate_team_report('WAS', mli_df, components)
generate_team_report('NYG', mli_df, components)

# Visualization

def plot_mli_components(mli_df, plays, player_play):
    team_colors = {
        'ARI': '#97233F', 'ATL': '#A71930', 'BAL': '#241773', 'BUF': '#00338D',
        'CAR': '#0085CA', 'CHI': '#0B162A', 'CIN': '#FB4F14', 'CLE': '#311D00',
        'DAL': '#003594', 'DEN': '#FB4F14', 'DET': '#0076B6', 'GB': '#203731',
        'HOU': '#03202F', 'IND': '#002C5F', 'JAX': '#101820', 'KC': '#E31837',
        'LA': '#003594', 'LAC': '#0080C6', 'LV': '#000000', 'MIA': '#008E97',
        'MIN': '#4F2683', 'NE': '#002244', 'NO': '#101820', 'NYG': '#0B2265',
        'NYJ': '#125740', 'PHI': '#004C54', 'PIT': '#FFB612', 'SEA': '#002244',
        'SF': '#AA0000', 'TB': '#D50A0A', 'TEN': '#0C2340', 'WAS': '#5A1414'
    }

    # MLI Distribution
    plt.figure(figsize=(15, 10))
    sns.boxplot(data=mli_df, y='MLI')
    plt.title('MLI Distribution Across Teams')
    plt.show()

    # Team Rankings
    plt.figure(figsize=(15, 8))
    sorted_data = mli_df.sort_values('MLI', ascending=False)

    # Create bar plot with team-specific colors
    bars = sns.barplot(data=sorted_data,
                      x=sorted_data.index,
                      y='MLI',
                      palette=[team_colors[team] for team in sorted_data.index])

    plt.xticks(rotation=45)
    plt.title('Team MLI Rankings')
    plt.show()

plot_mli_components(mli_df, plays, player_play)